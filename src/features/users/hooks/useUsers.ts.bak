import { useCallback } from "react";

import { useUserStore } from "../stores/user.store";
import type {
  IUserListFilter,
  ICreateUserInput,
  IUpdateUserInput,
  IUserProfile,
} from "../types/user.types";

interface IUseUsersReturn {
  users: IUserProfile[];
  isLoadingUsers: boolean;
  usersError: string | null;
  filter: IUserListFilter;
  hasMore: boolean;
  total: number;
  fetchUsers: (newFilter?: Partial<IUserListFilter>) => Promise<void>;
  createUser: (input: ICreateUserInput) => Promise<IUserProfile>;
  updateUser: (
    id: string,
    input: IUpdateUserInput,
  ) => Promise<Partial<IUserProfile> & { updatedAt: Date }>;
  deleteUser: (id: string) => Promise<void>;
  loadMore: () => Promise<void>;
  setFilter: (filter: Partial<IUserListFilter>) => void;
}

/**
 * Fetches users from the service
 */
const fetchUsersFromService = async (
  filter: IUserListFilter, // eslint-disable-line @typescript-eslint/no-unused-vars
): Promise<{
  users: IUserProfile[];
  total: number;
  hasMore: boolean;
}> => {
  // TODO: Replace with actual service call when implemented
  // const userService = getUserService()
  // return await userService.getUsers(filter)

  // Mock implementation for now
  return {
    users: [],
    total: 0,
    hasMore: false,
  };
};

/**
 * Creates a new user via service
 */
const createUserInService = async (
  input: ICreateUserInput,
): Promise<IUserProfile> => {
  // TODO: Replace with actual service call
  // const userService = getUserService()
  // return await userService.createUser(input)

  // Mock implementation
  return {
    id: crypto.randomUUID(),
    ...input,
    createdAt: new Date(),
    updatedAt: new Date(),
  };
};

/**
 * Updates user in service
 */
const updateUserInService = async (
  id: string,
  input: IUpdateUserInput,
): Promise<Partial<IUserProfile> & { updatedAt: Date }> => {
  // TODO: Replace with actual service call
  // const userService = getUserService()
  // return await userService.updateUser(id, input)

  // Mock implementation
  return { ...input, updatedAt: new Date() };
};

/**
 * Deletes user from service
 */
const deleteUserFromService = async (id: string): Promise<void> => { // eslint-disable-line @typescript-eslint/no-unused-vars
  // TODO: Replace with actual service call
  // const userService = getUserService()
  // await userService.deleteUser(id)

  // Mock implementation - no-op for now
  return Promise.resolve();
};

/**
 * Custom hook following Single Responsibility
 * Only handles user list operations
 */
export const useUsers = (): IUseUsersReturn => {
  const {
    users,
    isLoadingUsers,
    usersError,
    filter,
    hasMore,
    total,
    setUsers,
    addUser,
    updateUser: updateUserInStore,
    removeUser,
    setUsersLoading,
    setUsersError,
    setFilter,
    setHasMore,
    setTotal,
  } = useUserStore();

  const fetchUsers = useCallback(
    async (newFilter?: Partial<IUserListFilter>): Promise<void> => {
      try {
        setUsersLoading(true);
        setUsersError(null);

        const mergedFilter = { ...filter, ...newFilter };
        if (newFilter) {
          setFilter(newFilter);
        }

        const result = await fetchUsersFromService(mergedFilter);

        setUsers(result.users);
        setTotal(result.total);
        setHasMore(result.hasMore);
      } catch (error) {
        setUsersError(
          error instanceof Error ? error.message : "Failed to fetch users",
        );
      } finally {
        setUsersLoading(false);
      }
    },
    [
      filter,
      setUsers,
      setUsersLoading,
      setUsersError,
      setFilter,
      setTotal,
      setHasMore,
    ],
  );

  const createUser = useCallback(
    async (input: ICreateUserInput): Promise<IUserProfile> => {
      try {
        setUsersLoading(true);
        setUsersError(null);

        const newUser = await createUserInService(input);

        addUser(newUser);
        return newUser;
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : "Failed to create user";
        setUsersError(errorMessage);
        throw new Error(errorMessage);
      } finally {
        setUsersLoading(false);
      }
    },
    [addUser, setUsersLoading, setUsersError],
  );

  const updateUserById = useCallback(
    async (
      id: string,
      input: IUpdateUserInput,
    ): Promise<Partial<IUserProfile> & { updatedAt: Date }> => {
      try {
        setUsersLoading(true);
        setUsersError(null);

        const updates = await updateUserInService(id, input);

        updateUserInStore(id, updates);
        return updates;
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : "Failed to update user";
        setUsersError(errorMessage);
        throw new Error(errorMessage);
      } finally {
        setUsersLoading(false);
      }
    },
    [updateUserInStore, setUsersLoading, setUsersError],
  );

  const deleteUser = useCallback(
    async (id: string): Promise<void> => {
      try {
        setUsersLoading(true);
        setUsersError(null);

        await deleteUserFromService(id);

        removeUser(id);
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : "Failed to delete user";
        setUsersError(errorMessage);
        throw new Error(errorMessage);
      } finally {
        setUsersLoading(false);
      }
    },
    [removeUser, setUsersLoading, setUsersError],
  );

  const loadMore = useCallback(async (): Promise<void> => {
    if (!hasMore || isLoadingUsers) return;

    const nextOffset = users.length;
    await fetchUsers({ ...filter, offset: nextOffset });
  }, [hasMore, isLoadingUsers, users.length, filter, fetchUsers]);

  return {
    // State
    users,
    isLoadingUsers,
    usersError,
    filter,
    hasMore,
    total,

    // Actions
    fetchUsers,
    createUser,
    updateUser: updateUserById,
    deleteUser,
    loadMore,
    setFilter,
  };
};
